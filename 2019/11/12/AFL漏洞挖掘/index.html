<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>AFL漏洞挖掘 | nocbtm's Blog</title><meta name="description" content="AFL漏洞挖掘"><meta name="keywords" content="漏洞挖掘"><meta name="author" content="nocbtm"><meta name="copyright" content="nocbtm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon3.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://nocbtm.github.io/2019/11/12/AFL漏洞挖掘/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="AFL漏洞挖掘"><meta name="twitter:description" content="AFL漏洞挖掘"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="AFL漏洞挖掘"><meta property="og:url" content="https://nocbtm.github.io/2019/11/12/AFL漏洞挖掘/"><meta property="og:site_name" content="nocbtm's Blog"><meta property="og:description" content="AFL漏洞挖掘"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="分布式高并发tcp压力测试" href="https://nocbtm.github.io/2019/12/10/分布式高并发tcp压力测试/"><link rel="next" title="360杯 pwn writeup" href="https://nocbtm.github.io/2019/11/01/360杯-pwn-writeup/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://nocbtm.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">nocbtm's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/learn/"><i class="fa-fw fa fa-book"></i><span> 学习资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 大佬博客</span></a></li><li><a class="site-page" href="/link2/"><i class="fa-fw fa fa-book"></i><span> 学弟学妹们</span></a></li><li><a class="site-page" href="/link_vn/"><i class="fa-fw fa fa-link"></i><span> V&amp;N</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> (o≖◡≖)</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-area-chart"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 猫片</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/header1.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">88</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/learn/"><i class="fa-fw fa fa-book"></i><span> 学习资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 大佬博客</span></a></li><li><a class="site-page" href="/link2/"><i class="fa-fw fa fa-book"></i><span> 学弟学妹们</span></a></li><li><a class="site-page" href="/link_vn/"><i class="fa-fw fa fa-link"></i><span> V&amp;N</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> (o≖◡≖)</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-area-chart"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 猫片</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一-前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一 前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二-AFL简介"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">二 AFL简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三-选择和评估测试的目标"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">三 选择和评估测试的目标</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四-构建语料库"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">四 构建语料库</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-选择"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">1. 选择</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-寻找"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">2. 寻找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-修剪"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">3. 修剪</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五-构建被测试程序"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">五 构建被测试程序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-afl-gcc模式"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">1. afl-gcc模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-LLVM模式"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">2. LLVM模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六-开始Fuzzing"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">六 开始Fuzzing</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-白盒测试"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">1. 白盒测试</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-测试插桩程序"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">(1) 测试插桩程序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-执行fuzzer"><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">(2) 执行fuzzer</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#3-使用screen"><span class="toc_mobile_items-number">6.1.3.</span> <span class="toc_mobile_items-text">(3) 使用screen</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-黑盒测试"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">2. 黑盒测试</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七-结束测试"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">七 结束测试</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-何时结束"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">1.何时结束</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-输出结果"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">2. 输出结果</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#八-处理测试结果"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">八 处理测试结果</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-前言"><span class="toc-number">1.</span> <span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-AFL简介"><span class="toc-number">2.</span> <span class="toc-text">二 AFL简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-选择和评估测试的目标"><span class="toc-number">3.</span> <span class="toc-text">三 选择和评估测试的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-构建语料库"><span class="toc-number">4.</span> <span class="toc-text">四 构建语料库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-选择"><span class="toc-number">4.1.</span> <span class="toc-text">1. 选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-寻找"><span class="toc-number">4.2.</span> <span class="toc-text">2. 寻找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-修剪"><span class="toc-number">4.3.</span> <span class="toc-text">3. 修剪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-构建被测试程序"><span class="toc-number">5.</span> <span class="toc-text">五 构建被测试程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-afl-gcc模式"><span class="toc-number">5.1.</span> <span class="toc-text">1. afl-gcc模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LLVM模式"><span class="toc-number">5.2.</span> <span class="toc-text">2. LLVM模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-开始Fuzzing"><span class="toc-number">6.</span> <span class="toc-text">六 开始Fuzzing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-白盒测试"><span class="toc-number">6.1.</span> <span class="toc-text">1. 白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-测试插桩程序"><span class="toc-number">6.1.1.</span> <span class="toc-text">(1) 测试插桩程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-执行fuzzer"><span class="toc-number">6.1.2.</span> <span class="toc-text">(2) 执行fuzzer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-使用screen"><span class="toc-number">6.1.3.</span> <span class="toc-text">(3) 使用screen</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-黑盒测试"><span class="toc-number">6.2.</span> <span class="toc-text">2. 黑盒测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-结束测试"><span class="toc-number">7.</span> <span class="toc-text">七 结束测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-何时结束"><span class="toc-number">7.1.</span> <span class="toc-text">1.何时结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-输出结果"><span class="toc-number">7.2.</span> <span class="toc-text">2. 输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-处理测试结果"><span class="toc-number">8.</span> <span class="toc-text">八 处理测试结果</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">AFL漏洞挖掘</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-09</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/漏洞挖掘/">漏洞挖掘</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3,734</span><span class="post-meta__separator">|</span><span>阅读时长: 13 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>转载于 ：<a href="https://www.freebuf.com/articles/system/191543.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/191543.html</a></p>
<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。</p>
<p><img alt="" data-src="https://i.loli.net/2019/11/17/gpEyeKHY6JqSQPz.jpg" class="lozad"></p>
<h2 id="二-AFL简介"><a href="#二-AFL简介" class="headerlink" title="二 AFL简介"></a>二 AFL简介</h2><p>AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下：</p>
<ul>
<li><p>①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</p>
</li>
<li><p>②选择一些输入文件，作为初始测试集加入输入队列（queue）；</p>
</li>
<li><p>③将队列中的文件按一定的策略进行“突变”；</p>
</li>
<li><p>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</p>
</li>
<li><p>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。</p>
</li>
</ul>
<p><img alt="" data-src="https://i.loli.net/2019/11/17/26iNMIudQhyRXpG.jpg" class="lozad"></p>
<h2 id="三-选择和评估测试的目标"><a href="#三-选择和评估测试的目标" class="headerlink" title="三 选择和评估测试的目标"></a>三 选择和评估测试的目标</h2><p>开始Fuzzing前，首先要选择一个目标。 AFL的目标通常是接受外部输入的程序或库，输入一般来自文件（也可以Fuzzing一个网络程序）。</p>
<ol>
<li><p>用什么语言编写<br>AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。（也有一些基于AFL的JAVA Fuzz程序如kelinci、java-afl等）</p>
</li>
<li><p>是否开源<br>AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。</p>
</li>
<li><p>程序版本<br>目标应该是该软件的最新版本，不然辛辛苦苦找到一个漏洞，却发现早就被上报修复了就尴尬了。</p>
</li>
<li><p>是否有示例程序、测试用例<br>如果目标有现成的基本代码示例，特别是一些开源的库，可以方便我们调用该库不用自己再写一个程序；如果目标存在测试用例，那后面构建语料库时也省事儿一点。</p>
</li>
<li><p>项目规模<br>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它treemap功能，可以直观地看到项目结构和规模。</p>
</li>
<li>程序曾出现过漏洞<br>如果某个程序曾曝出过多次漏洞，那么该程序有仍有很大可能存在未被发现的安全漏洞。</li>
</ol>
<h2 id="四-构建语料库"><a href="#四-构建语料库" class="headerlink" title="四 构建语料库"></a>四 构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpge图像！</p>
<p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p>
<h3 id="1-选择"><a href="#1-选择" class="headerlink" title="1. 选择"></a>1. 选择</h3><p>(1) 有效的输入</p>
<p>尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</p>
<p>(2) 尽量小的体积</p>
<p>较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。</p>
<h3 id="2-寻找"><a href="#2-寻找" class="headerlink" title="2. 寻找"></a>2. 寻找</h3><p>使用项目自身提供的测试用例</p>
<p>目标程序bug提交页面</p>
<p>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</p>
<p>afl源码的testcases目录下提供了一些测试用例</p>
<p>其他开源的语料库</p>
<h3 id="3-修剪"><a href="#3-修剪" class="headerlink" title="3. 修剪"></a>3. 修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。<br>(1) 移除执行相同代码的输入文件——afl-cmin</p>
<p>afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</span><br></pre></td></tr></table></figure></p>
<p>更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure></p>
<p>(2) 减小单个输入文件的大小——afl-tmin<br>整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。</p>
<p>afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure></p>
<p>如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure>
<p>afl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> afl-tmin -i <span class="variable">$i</span> -o tmin-<span class="variable">$i</span> -- ~/path/to/tested/program [params] @@; <span class="keyword">done</span>;s</span><br></pre></td></tr></table></figure>
<h2 id="五-构建被测试程序"><a href="#五-构建被测试程序" class="headerlink" title="五 构建被测试程序"></a>五 构建被测试程序</h2><p>前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别</p>
<h3 id="1-afl-gcc模式"><a href="#1-afl-gcc模式" class="headerlink" title="1. afl-gcc模式"></a>1. afl-gcc模式</h3><p>afl-gcc/afl-g++作为gcc/g++的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为afl-gcc/afl-g++就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改Makefile文件中的编译器为afl-gcc/g++也行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure CC=<span class="string">"afl-gcc"</span> CXX=<span class="string">"afl-g++"</span></span><br></pre></td></tr></table></figure>
<p>在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --<span class="built_in">disable</span>-shared CC=<span class="string">"afl-gcc"</span> CXX=<span class="string">"afl-g++"</span></span><br></pre></td></tr></table></figure>
<h3 id="2-LLVM模式"><a href="#2-LLVM模式" class="headerlink" title="2. LLVM模式"></a>2. LLVM模式</h3><p>LLVM Mode模式编译程序可以获得更快的Fuzzing速度，进入llvm_mode目录进行编译，之后使用afl-clang-fast构建序程序即可，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> llvm_mode$ apt-get install clang$ <span class="built_in">export</span> LLVM_CONFIG=`<span class="built_in">which</span> llvm-config` &amp;&amp; make &amp;&amp; <span class="built_in">cd</span> ..$ ./configure --<span class="built_in">disable</span>-shared CC=<span class="string">"afl-clang-fast"</span> CXX=<span class="string">"afl-clang-fast++"</span></span><br></pre></td></tr></table></figure>
<p>在使用高版本的clang编译时可能会报错，换成clang-3.9后通过编译，如果你的系统默认安装的clang版本过高，可以安装多个版本然后使用update-alternatives切换。</p>
<h2 id="六-开始Fuzzing"><a href="#六-开始Fuzzing" class="headerlink" title="六 开始Fuzzing"></a>六 开始Fuzzing</h2><h3 id="1-白盒测试"><a href="#1-白盒测试" class="headerlink" title="1. 白盒测试"></a>1. 白盒测试</h3><h4 id="1-测试插桩程序"><a href="#1-测试插桩程序" class="headerlink" title="(1) 测试插桩程序"></a>(1) 测试插桩程序</h4><p>编译好程序后，可以选择使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png[*] Executing <span class="string">'./build/bin/imagew'</span>...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples <span class="keyword">in</span> <span class="string">'/dev/null'</span>.</span><br></pre></td></tr></table></figure>
<p>使用不同的输入，正常情况下afl-showmap会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的afl-cmin就是通过这个工具来去掉重复的输入文件。</p>
<h4 id="2-执行fuzzer"><a href="#2-执行fuzzer" class="headerlink" title="(2) 执行fuzzer"></a>(2) 执行fuzzer</h4><p>在执行afl-fuzz前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改core_pattern文件，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
<p>之后就可以执行afl-fuzz了，通常的格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params]</span><br></pre></td></tr></table></figure>
<p>或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure>
<p>如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，比如下图中提示有个较大的文件（14.1KB），且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。</p>
<p>测试源代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"it is good!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AFL状态窗口</p>
<p><img alt="" data-src="https://i.loli.net/2019/11/17/tD5GNCSJ4nAxukH.png" class="lozad"></p>
<p>① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p>
<p>② Overall results：Fuzzer当前状态的概述。</p>
<p>③ Cycle progress：我们输入队列的距离。</p>
<p>④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p>
<p>⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</p>
<p>⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p>
<p>⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p>
<p>⑧ Path geometry：有关Fuzzer找到的执行路径的信息。</p>
<p>⑨ CPU load：CPU利用率</p>
<h4 id="3-使用screen"><a href="#3-使用screen" class="headerlink" title="(3) 使用screen"></a>(3) 使用screen</h4><p>一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></p>
<p>也可以为每个session命名，方便重新连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]$ screen -r fuzzer1  ...</span><br></pre></td></tr></table></figure></p>
<h3 id="2-黑盒测试"><a href="#2-黑盒测试" class="headerlink" title="2. 黑盒测试"></a>2. 黑盒测试</h3><p>所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突，在这里可以找到针对QEMU的patch，之后运行脚本build_qemu_support.sh就可以自动下载编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ </span><br><span class="line">$ <span class="built_in">cd</span> qemu_mode$ build_qemu_support.sh$ <span class="built_in">cd</span> .. &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>现在起，只需添加-Q选项即可使用QEMU模式进行Fuzzing。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@</span><br></pre></td></tr></table></figure></p>
<h2 id="七-结束测试"><a href="#七-结束测试" class="headerlink" title="七 结束测试"></a>七 结束测试</h2><h3 id="1-何时结束"><a href="#1-何时结束" class="headerlink" title="1.何时结束"></a>1.何时结束</h3><p>检查afl-fuzz工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。</p>
<p>（1）状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。</p>
<p>（2）距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。</p>
<p>（3）目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。</p>
<p>（4）上面提到的pythia提供的各种数据中，一旦path covera达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是correctness的值达到1e-08，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。</p>
<h3 id="2-输出结果"><a href="#2-输出结果" class="headerlink" title="2. 输出结果"></a>2. 输出结果</h3><p>afl-fuzz的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例：<br><img alt="" data-src="https://i.loli.net/2019/11/19/FNkeoOia15yUQXK.png" class="lozad"></p>
<p>queue：存放所有具有独特执行路径的测试用例。</p>
<p>crashes：导致目标接收致命signal而崩溃的独特测试用例。</p>
<p>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。</p>
<p>hangs：导致目标超时的独特测试用例。</p>
<p>fuzzer_stats：afl-fuzz的运行状态。</p>
<p>plot_data：用于afl-plot绘图。</p>
<h2 id="八-处理测试结果"><a href="#八-处理测试结果" class="headerlink" title="八 处理测试结果"></a>八 处理测试结果</h2><p>到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">nocbtm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nocbtm.github.io/2019/11/12/AFL漏洞挖掘/">https://nocbtm.github.io/2019/11/12/AFL漏洞挖掘/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nocbtm.github.io">nocbtm's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/漏洞挖掘/">漏洞挖掘    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechatpay.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/10/分布式高并发tcp压力测试/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>分布式高并发tcp压力测试</span></div></a></div><div class="next-post pull-right"><a href="/2019/11/01/360杯-pwn-writeup/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>360杯 pwn writeup</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2021 By nocbtm</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/baidupush.js"> </script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":"wanko","mobileShow":false,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>